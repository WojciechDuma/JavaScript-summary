<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta http-equiv="X-UA-Compatible" content="ie=edge" />
  <title>JavaScript - knowledge summary</title>

  <style>
    html {
      scroll-behavior: smooth;
    }

    body {
      max-width: 80%;
      margin: auto;
      background-color: #434343;
      color: #efefef;
      font-size: 20px;
      font-family: roboto, arial, sans-serif;
    }

    pre {
      min-width: 1000px;
      padding-top: 20px;
      border-radius: 10px;
      background-color: #f5f5f5;
      color: black;
      font-size: 0.9em;
    }

    span {
      color: royalblue;
      font-weight: bold;
    }

    .lineThrough {
      text-decoration: line-through;
      color: goldenrod;
      font-size: 1em;
    }

    h4 {
      color: chocolate;
      font-style: italic;
    }

    a {
      text-decoration: none;
      color: white;
      transition: 0.3s;
    }

    a:hover {
      color: royalblue;
    }

    .lineThrough {
      text-decoration: line-through;
      color: goldenrod;
      font-size: 1em;
    }
  </style>
</head>

<body>
  <h2>JavaScript knowledge summary:</h2>

  <h3>Spis treści:</h3>
  <ul>
    <li><a href="#variables">Variables</a></li>
    <li><a href="#operators">Operators</a></li>
    <li><a href="#string">String</a></li>
    <li><a href="#number">Number</a></li>
    <li><a href="#conditions">Conditions</a></li>
    <li><a href="#loops">Loops</a></li>
    <li><a href="#arrays">Arrays</a></li>
    <li><a href="#function">Function</a></li>
    <li><a href="#date">Date</a></li>
    <li><a href="#math">Math</a></li>
    <li><a href="#dom">Document Object Model</a></li>
    <li><a href="#tryCatch">Try...catch</a></li>
    <li><a href="#objects">Objects</a></li>
    <li><a href="#class">Class</a></li>
    <li><a href="#iterator">Iterators</a></li>
    <li><a href="#generators">Generators</a></li>
    <li><a href="#asynchronous">Asynchronous JS</a></li>
    <li><a href="#modules">Modules</a></li>
    <li><a href="#other">Others</a></li>
  </ul>

  <section>
    <h3 id="variables">Variables:</h3>
    <pre>
      <span>var:</span>
        - zasięg funkcyjny,
        - hoisting,
        - obiekt globalny (w window),
        - można deklarować ponownie.

      <span>let:</span> 
        - zasięg blokowy,
        - brak hositingu,
        - nie można redeklarować:
        <span class="lineThrough">let a = 5, let a = 7</span> 
        let a = 5, a = 7.
          
      <span>const:</span>
        - zasięg blokowy,
        - brak hositingu,
        - stała wartość bez możliwości redeklaracji,
        - ochrona wartości i referencji 
        (można modyfikować obiekty, które są przypisane),
        - trzeba zawsze zainicjować <span class="lineThrough">(const a)</span> (const a = 5).
    </pre>
  </section>

  <section>
    <h3 id="operators">Operators</h3>
    <pre>
      let value = 2

      inkrementacja: <span>value++</span>      // najpierw zwraca potem dodaje
      dekrementacja: <span>value--</span>     // najpierw zwraca potem odejmuje
      preinkrementacja: <span>++value</span>   // najpierw dodaje potem zwraca
      predekrementajca: <span>--value</span>   // najpierw odejmuje potem zwraca

      value += 10     // 12
      value -= 10     // -8
      value *= 10     // 20
      value /= 10     // 0.2

      <span>%</span> - modulo, reszta z dzielenia
      10 % 9          // 1

      <span>**</span> - potęga
      2**5            // 32

      <span>==</span>      równe
      <span>!=</span>     nie równe
      <span>===</span>     identyczne (wartość i typ)
      <span>!==</span>     nieidentyczny (wartość lub typ)
      <span>></span>     większe niż
      <span>&lt</span>     mniejsze niż
      <span>>=</span>     większy lub równy
      <span>&lt=</span>     mniejszy lub równy

      Object.is()   to jest to samo co ===
      np. Object.is(1, 1)     // true

      <span>&&</span>      Logiczne "i", wszystkie warunki muszą być true
      <span>||</span>      Logiczne "lub", jeden warunek musi być true
      <span>!</span>       Logiczne "nie"

      Operator trójargumentowy (ternary operator):

      <span>conditional ? (if condition is true) : (if condition is false);</span>

      np.: 3 > 2 ? "tak" : "nie";     // tak
    </pre>
  </section>

  <section>
    <h3 id="string">String</h3>
    <pre>
      let name = Wojciech;
          
      name.toUpperCase();     // WOJCIECH
      name.toLowerCase();     // wojciech
      name.length;            // 8
      name[2];                // j
      name.charArt(2);        // j
      name.indexOf('o')       // 1
      name.includes('c')      // true
      name.slice(1,4)         // ojc
      name.slice(-3)          // ech - wycina ostatnie 3 litery
      .slice(start, end) - wycinanie fragmentu łańcucha,
                           start(początek), end(koniec - bez tego)
      .trim();           - pozbywa się białych znaków na początku i końcu łańcucha
      .repeat();         - skopiowanie łańcucha
      .replace('first', 'second'); - zamienia first na second
      .include('word');  - sprawdza czy 'word' jest w stringu
          
      String(100);        // "100", konwersja na String
    </pre>
  </section>

  <section>
    <h3 id="number">Number</h3>
    <pre>
      .toFixed() - zaokrąglenie, zwraca wartość która jest stringiem
      .toFixed()      // zaokrągla do liczby całkowitej
      .toFixed(1)     // zaokrągla do jednego miejsca po przecinku

      .toString() - zmiana, konwersja na String
      .toString()     // zamiana na system dziesiętny
      .toString(2)    // zamiana na system dwójkowy

      .parseInt() - zamiana na liczbę całkowitą
      .parseFloat() - zamiana na liczbę dziesiętną

      Number.isInteger()  - czy liczba jest całkowita
      Number.isFinite()   - czy liczba jest skończona
      Number('200')       // 200, konwersja na Number
      Number(true)        // 1
      Number("")          // 0
    </pre>
  </section>

  <section>
    <h3 id="conditions">Conditions</h3>
    <pre>
      if (warunek) {
          Tu operacje;
      } else if (warunek_2) {
          Kolejne operacje;
      } else {
          Ostatnie operacje;
      }

      ---------------------------------------

      switch(expression){
          case 0: 
              operacje
              break;
          case 1:
                operacje
                break;
          case n:
              operacje
              break;
          default:
              operacje
      }

      Przykład:

      switch (new Date().getDay()) {
          case 0:
              day = "Sunday";
              break;
          case 1:
              day = "Monday";
              break;
          case 2:
              day = "Tuesday";
              break;
          case 3:
              day = "Wednesday";
              break;
          case 4:
              day = "Thursday";
              break;
          case 5:
              day = "Friday";
              break;
          case 6:
              day = "Saturday";
      }
    </pre>
  </section>

  <section>
    <h3 id="loops">Loops</h3>
    <pre>
      for(inicjalizacja; warunek; inkrementacja){
          operacje;
      }

      for(let i = 0; i &lt 10; i++){
          console.log(i);
      }

      ---------------------------------------

      while (warunek){
          powtarzane operacje;
      }

      let i = 0;
      while (i &lt 10){
          i++;
          console.log(i);
      }

      ---------------------------------------

      do {
          powtarzane operacje;
      } while (warunek);

      ---------------------------------------

      for (const jakaśNazwaZmiennej of tablica ){
          operacja iteracji po każdym elemencie tablicy;
      }

      np:
      const arr = [1, 2, 3, 4, 5];

      for (const number of arr){
          console.log(i);
      }

      // 1, 2, 3, 4, 5

      ---------------------------------------
      for (let nazwaZmiennej in nazwaObiektu){
        // some code...
      }

      np:

      const user = {
        firstName: 'John',
        lastName: 'Smith',
        age: 30
      }

      for(let key in user){
        console.log(key);     // firstName, lastName, age
      }

      for(let key in user){
        console.log(user[key]);     // John, Smith, 30
      }
    </pre>
  </section>

  <section>
    <h3 id="arrays">Arrays</h3>
    <pre>
      const newArray = []     // tworzenie tablicy

      <span>.length;</span>       // zwraca długość tablicy
      newArray.length = 0;    // zerowanie tablicy

      <span>.push();</span>       // dodaje element na koniec tablicy
      <span>.unshift();</span>    // dodawanie elementu na początku tablicy
      <span>.pop();</span>        // usuwa ostatni element z tablicy
      <span>.shift();</span>      // usuwa pierwszy element z tablicy
      <span>.concat();</span>     // dodawanie tablic do siebie i tworzenie nowej
          newArray = firstArray.concat(secondArray);
          ES6: newArray = [...firstArray, ...secondArray];

      <span>.slice();</span>
      newArray.slice(2);      // wycinamy od 2 indexu
      newArray.slice(2,5);    // wycinamy od 2 indeksu do 5 indexu (ale bez niego)
      newArray.slice(0);      // pobieramy całą tablice
      newArray.slice(-1);     // zwraca ostatni element
      newArray.slice(-3);     // zwraca 3 ostatnie elementy

      <span>.splice();</span>
      newArray.splice(2);     // usuwa wszystkie elementy od indexu 2
      newArray.splice(0,1);   // usuwa od indexu 0, jeden element
      newArray.splice(0);     // zeruje całą tablice
      newArray.splice(0,1, "somethink");   // usuwa element i od razu dodaje

      <span>.sort();</span>        // sortowanie alfabetyczne
      <span>.indefOf();</span>     // szuka elementu w tablicy i zwraca jego index
      <span>.lastIndexOf();</span> // szuka od końca
      <span>.includes();</span>    // sprawdza tablice czy zawiera element, zwraca true, false
      <span>.join();</span>        // otrzymujemy stringa oddzielonego przecinkami
      <span>.join(" --- ");</span> // otrzymujemy stringa oddzielonego ---
      <span>.reverse();</span>     // odwraca kolejność tablicy
      <span>.split("");</span>     // zamienia string na tablice, "someString".split(""); 
      <span>.find();</span>        // zwraca element, który jako pierwszy zwróci true

      <span>
        someArray.sort(function(x, y){
          return x - y;    //sortowanie liczb od najmniejszej
        })
      </span>
      <span>
          someArray.sort(function(x, y){
            return y - x;    //sortowanie liczb od największej
          })
      </span>
      <span>Array.isArray(nazwa)</span> - sprawdza czy podana wartość jest tablicą
      <span>Array.from()</span> - pozwala tworzyć tablice z elementów tablicopodobnych
        np: let newArr = Array.from('WOJCIECH');

      ################################

      <span>.map();</span>         // map tworzy nowa tablica o tej samej długości
      const = numbers = [2, 3, 4];
      const doubleNumbers = numbers.map(number => number * 2); // [4, 6, 8];

      ################################

      <span>.filter();</span>      // zwraca nową tablice złożoną z tych elementów,
                          przy których iterator zwrócił true.
      
      const users = ['adam', 'janek', 'bolek', 'leon'];
      const nameSixLetter = users.filter(user => user.length === 5);

      // nameSixLetter = ['janek', 'bolek'];

      ################################

      <span>.forEach(); </span>    // iteracja po elementach tablicy

      .forEach( elementy, index, tablica ) --> mamy 3 parametry:
                  - elementy - są to kolejne elementy z tablicy
                  - index - sa to kolejne indexy z tablicy
                  - tablica - jest to tablica na której wykonujemy .forEach

      const usersAge = [20, 30, 40, 50];
      let usersAgeAll = 0;

      usersAge.forEach(age => usersAgeAll += age);
      
      // usersAgeAll = 140

      ################################

      <span>Destructuring Arrays:</span>

      const [firstName, lastName, age] = [Jan, Kowalski, 25];
      lub
      const info = [Jan, Kowalski, 25];
      const [firstName, lastName, age] = info;

      firstName       // Jan
    </pre>
  </section>

  <section>
    <h3 id="function">Function</h3>
    <pre>
      Wyrażenie funkcyjne (Function Expression):

      const fName = function() {
          code;
      };

      fName();        // wywołanie funkcji;

      ---------------------------------------
      Deklaracja funkcji:

      function fName() {
          code;
      };

      np. function addNumber(x, y) {
          return x + y;
      };

      ---------------------------------------
      Funkcja strzałkowa (Arrow function):

      const fName = () => {
          code;
      };
      
      - nie można wymusić co ma być pod 'this' wewnątrz funkcji,
      - funkcja ma dostęp do 'this' które jest zdefiniowane o jeden zakres wyżej,
      - funkcje strzałkowe nie mają prototypu.

      Return object:
      const sayHello = () => ({ message: 'Hello'}); 
      
      - trzeba objąć ciało funkcji w nawiasy ();

      ---------------------------------------
      Wartości domyśle w funkcji:

      const fName = (x = 1, y = 0) => {
          let result = x + y;
          return result;
      };

      ---------------------------------------
      Callback:

      function add(number){
          number++;
          return number;
      }

      function count(x, callback){
          return callback(x);
      }
      
      count(5, add);      // 6

      Inny przykład callback to:
      a) .addEventListener("click", showSomethink);
      b) setInterval(showTime, 2000);

      ---------------------------------------
      Immidiatley invokable function expression - IIFEs
      - funkcja którą deklarujemy i wywołujemy 'w tym samym czasie'

      (function(){
        // somecode...
      })();

      (function(parametr){
        // somecode...
      })('parametr');
    </pre>
  </section>

  <section>
    <h3 id="date">Date</h3>
    <pre>
      const today = new Date();

      today.getFullYear();
      today.getMonth(); // 0 - January, 11 - December
      today.getDay();   // 0 - Sunday, 6 - Saturday
      today.getDate();  // zwraca numer dnia
      today.getHours();
      today.getMinutes();
      today.getSeconds();
      today.getTime();  // czas w sekundach od 01.01.1970
    </pre>
  </section>

  <section>
    <h3 id="math">Math</h3>
    <pre>
      Math.PI
      Math.E

      Math.round(2.6);  // 3
      Math.round(2.4);  // 2
      Math.ceil(2.4);   // 3, zawsze zaokrągla do góry
      Math.floor(2.8);  // 2, zawsze zaokrągla do dołu

      Math.sqrt(64);    // 8, pierwiastek
      Math.abs(-4);     // 4, wartość bezwględna
      Math.pow(8, 2);   // 64, potęga

      Math.random();    // random between 0-1

      Math.floor(Math.random() * 10);      // od 0 do 10 (bez 10)

      // od min do max (bez max)
      const randomNumber = (min, max) => {
          const number = Math.floor(Math.random() * (max - min) + min);
          return number;
      }

      // od min do max (z max)
      const randomNumber = (min, max) => {
          const number = Math.floor(Math.random() * (max - min + 1) + min);
          return number;
      }
    </pre>
  </section>

  <section>
    <h3 id="dom">Document Object Model</h3>
    <pre>
      Pobieranie elementu:

      document.querySelector('selector');
      document.getElementyById('idName');
      document.querySelectorAll('selectory');     // nodeList
      document.getElementsByTagName('');          // HTMLCollections
      document.getElementsByClassName('');        // HTMLCollections

      ---------------------------------------
      Modyfikacja elementów:

      <span>.textContent = "Nowy kontent";</span>            // zmiana tesktu
      <span>.innerHTML = '&ltp>Nowy element &lt/p>';</span>  // dodanie nowego elementu
      <span>.classList.add('someClass');</span>              // dodawanie klasy
      <span>.classList.remove('someClass');</span>           // usuwanie klasy
      <span>.classList.toggle('someClass');</span>           // przełączanie klasy
      <span>.replace(firstElement, secondElement)</span>     // zamiana elementów
      <span>.remove()</span>                                 // usuwanie elementu
      <span>.removeChild(child[i])</span>                    // usuwanie konkrentego elementu
      
      .style.key = "value"; 
        np:
        .style.fontSize = "30px";
        .style.backgroundColor = "#000";

      ---------------------------------------
      Dodawanie elementów

      <span>.createElement('');</span>     // tworzenie
      <span>.createTextNode('');</span>    // tworzenie tekstu w elemencie
      <span>.appendChild();</span>         // dodawanie
      <span>.insertBefore();</span>        // dodawanie elementu przed innym elementem
        elementRodzica.insertBefore(nowyElement, innyElement);

      ---------------------------------------
      Zdarzenia:

      .addEventListener('event', functionCallback);
      .addEventListener('event', function(){
        // code;
      });
      .addEventListener('event', () => {
        // code;
      });

      function callbackFunctionName(event){}

      <span>event.preventDefault();</span> - zapobiega domyślnemu zachowaniu elementu
      <span>event.target</span> - dostęp do elementu ze zdarzenia
      <span>event.clientX</span> - odległość w pixelach w odniesieniu do okna przeglądrki
      <span>event.clientY</span> - odległość w pixelach w odniesieniu do okna przeglądrki
      <span>event.offsetX</span> - odległość w pixelach w odniesieniu do elementu
      <span>event.offsetY</span> - odległość w pixelach w odniesieniu do elementu
      <span>event.key</span> - jaki wcisneliśmy klawisz
      <span>event.code</span> - kod wciśniętego klawisza

      Mouse events: 
      - <span>click</span>         // pojedyncze kliknięcie
      - <span>dblclick</span>      // podwójne kliknięcie
      - <span>mousedown</span>     // naciśnięcie
      - <span>mouseup</span>       // po puszczeniu naciśnięcia
      - <span>mouseenter</span>    // najechanie myszką na element główny
      - <span>mouseleave</span>    // zjechanie z elementu głównego
      - <span>mouseover</span>     // najechanie na element - elementu głównego
      - <span>mouseout</span>      // zjechanie z elementu - elementu głównego
      - <span>mousemove</span>     // ruch myszką

      Keyboard events:
      - <span>keydown</span>       // naciskamy przycisk
      - <span>keypress</span>      
      - <span>keyup</span>         // puszczamy przycisk

      Other:
      - <span>submit</span>        // zatwierdzanie np. formularza
      - <span>input</span>         // cokolwiek robimy w input
      - <span>focus</span>         // np. kiedy klikamy w wewnątrz inputa
      - <span>blur</span>          // np. kiedy klikamy po zewnątrz inputa
      - <span>cut</span>           // kiedy zaznaczamy tekst i go wycinamy
      - <span>paste</span>         // kiedy wklejamy tekst
      - <span>change</span>        // kiedy zmieniamy wybór np. w select
      - <span>resize</span>        // zmiana rozmiaru okna przeglądarki
      - <span>scroll</span>        // zdarzenie scrolowania strony lub elementu
      - <span>animationstart</span>
      - <span>animationiteration</span>
      - <span>animationend</span>

      ---------------------------------------
      Inne:

      <span>.getAttribute('attribute')</span> - pobieranie atrybutu
      <span>.setAttribute('key', 'value')</span> - ustawianie atrybutu
      <span>.removeAttribute('attribute')</span> - usuwanie atrybutu
      <span>.hasAttribute('attribute')</span> - sprawdza czy ma atrybut, zwraca true/false
      <span>.textContent</span> - pobiera lub ustawia tekst
      <span>.innerHTML</span> - pobiera lub ustawia tekst ze znacznikami
      <span>.classList</span> - dostanie się do wszystkich klas elementu
      <span>.className</span> - dostanie się do klasy, nadpisuje
      <span>.id</span> - dostanie się do ID, nadpisuje

      <span>window.innerHeight</span> - określa jaką wielkość ma okno przeglądarki wewnątrz
      <span>window.innerWidth</span> - określa jaką szerokość na okno przeglądarki wewnątrz
      <span>window.outerHeight</span> - określa jaką wielkość ma okno przeglądarki po zewnątrz
      <span>window.outerWidth</span> - określa jaką szerokość na okno przeglądarki po zewnątrz
      <span>window.scrollY</span> 
      <span>window.scrollX</span>
      <span>window.location</span> - .hostname, .port, .href, .search, .reload()
      <span>window.history.go()</span> - .go(-1) - przeniesie nas na stronę wcześniej
      <span>window.navigator</span> - informacje o przeglądarce 

      <span>document.domain</span>  - adres strony
      <span>document.URL</span> - pełen adres
      <span>document.all.length</span> - ilość wszystkich znaczników

      <span>.childNodes</span> - dostęp do dzieci NodeList
      <span>.childNodes[i].nodeType</span> - 1: Element, 3: Text, 8: Comment
      <span>.children</span> - dostęp do HTMLCollection
      <span>.children[i]</span> - dostęp do i-tego elementu
      <span>.firstElementChild</span> - dostęp do pierwszego elementu
      <span>.childElementCount</span> - ilość elementów
      <span>.parentNode / .parentElement</span> - dostęp do rodzica
      <span>.firstChild</span>
      <span>.nextSibiling</span>
      
      ---------------------------------------
      Local Storage:

      localStorage.setItem('key', 'value');   // zapisanie
      localStorage.removeItem('key');         // usunięcie
      localStorage.getItem('key');            // pobranie
      localStorage.clear();                   // czyszczenie
      JSON.stringfy()                         // zamiana obiektu JavaScript na JSON (string)
      JSON.parse()                            // zamiana JSON (stringa) na obiekt JavaScript
    </pre>
  </section>

  <section>
    <h3 id="tryCatch">Try...catch</h3>
    <pre>
      <span>try {</span>
        // Some program

        if(something.is.bad){
          <span>throw</span> 'Something is wrong';
        }
      <span>} catch(error) {</span>
        // if there are some errors:
        error
        error.message 
        error.name
      <span>} finally {</span>
        // run regardless of result
      <span>}</span>
    </pre>
  </section>

  <section>
    <h3 id="objects">Objects</h3>
    <pre>
      Literał obiektu:
      <span>const objectsName = {};</span>

      Tworzenie obiektu:
      <span>
      const someName = {
          key: value,
          key_2: value_2,
          fName() {
              function code;
              this.key;
          },
      }
      </span>
      Dodawanie dynamiczne do obiektu:
      <span>someName.key_3 = value_3;</span>
      Usuwanie:
      <span>delete someName.key_3;</span>

      ---------------------------------------
      This odwołuje się do obiektu na którym wykonywana jest metoda:
      <span>
      const counter = {
          score: 0;

          increment() {
              this.score++;
          }
      }
      counter.increment();        // 1
      counter.increment();        // 2
      </span>
      ---------------------------------------
      Tworzenie konstruktora:
      <span>
      function FirstName(name_1, name_2){
          this.name_1 = name_1;
          this.name_2 = name_2;
          this.name_3 = function() {
              ...
          }
      }    
      </span>
      Tworzenie instancji:
      <span>
      const nazwa = new FirstName("one", "two");
      </span>
      Prototyp - aby uniknąć tworzenia metody do każdej instancji,
                 można użyć prototypu - 'wyciągnąć' metodę z konstruktora:
      <span>
      FirstName.prototype.name_3 = function(name_4){
          this.name_4 = name_4;
          ...
      }
      </span>
      Dziedziczenie:
      <span>
      function SecondName(name_1, name_2, someOther, anotherParametr){
        FirstName.call(this, name_1, name_2);
        this.someOther = someOther;
        this.anotherParametr = anotherParametr;
      }
      </span>
      Dziedziczenie prototypu:
      <span>
        SecondName.prototype = Object.create(FirstName.prototype);
        SecondName.prototype.constructor = SecondName;
      </span>
    </pre>
  </section>

  <section>
    <h3 id="class">Class</h3>
    <pre>
      Deklaracja:
      <span>class Species {}</span>

      Tworzenie instancji klasy:
      <span>const human = new Species();</span>

      class ClassName {
          constructor(arg1, arg2, arg3){
              this.arg1 = arg1;
              this.arg2 = arg2;
              this.arg3 = arg3;
          }
          newMethod_1() {
              ...
          }
          newMethod_2() {
              ...
          }

          static anotherName(arg_4) {
              ...
          }
      }

      Wywołanie metody statycznej:

      ClassName.anotherName(...);
      Tak jak wywołujemy np. Math.floor() itp.

      Dziedziczenie:

      class ClassName_1 <span>extends</span> ClassName_2 {
          constructor(first, second) {
              <span>super(first);</span> // wywołuje konstruktor 'rodzica', klasy z której dziedziczymy, klasy nadrzędnej
              this.second = second; // rozszerzone, własne konstruktory
          }
      }
    </pre>
  </section>

  <section>
    <h3 id="iterator">Iterators:</h3>
    <pre>
      Możemy iterować petlą <span>for - of</span> po każdym obiekcie z symbol.iterator

      1. Iteracja po tablicy:
      <span>
      const arr = [1, 2, 3, 4, 5];
      for (const number of arr){
          console.log(i);
      }
      </span>
      2. Iteracja po stringu
      <span>
      for(let character of "Wojciech"){
        console.log(character);
      }
      </span>
      3. Można iterować po nodeList
      <span>
      const lista = document.querySelectorAll('li');
      for(let li of lista ){
        consol.log(li);
      }
      </span>
    </pre>
  </section>

  <section>
    <h3 id="generators">Generators:</h3>
    <pre>
      Tworzymy generator z <span>*</span>(gwiazdką) w nazwie:
      
      function *name() {
        yield 1;
        yield 2;
        yield 3;
      }

      Tworzymy iterator, który ma w sobie funkcje <span>next()</span>:
      
      let iterator = name();
      iterator.next();
      for(let value of iterator){
        console.log(value);   // 1,2,3
      }
      
      funkcja next() zwraca dwie wartości: 'value' oraz 'done'
      
      ____________________________________________
      przykład:
      function *range(from, to) {
        while (from &lt= to){
          yield from++;
        }
      }
      for(let value of range(5, 10)){
        console.log(value);   // 5,6,7,8,9,10
      }
    </pre>
  </section>

  <section>
    <h3 id="asynchronous">Asynchronous JS</h3>
    <pre>
        <span>HTTP status:</span>
        200: 'OK'
        403: 'Forbidden'
        404: 'Not Found'

        <span>readyState Values:</span>
        0: request not initialized;
        1: server connection established
        2: request received
        3: processing request
        4: request finished and response is ready

        <span>AJAX:</span>
        // Tworzenie XHR Object:
        - const xhr = new XMLHttpRequest(); 

        // Otwieranie:
        - xhr.open('GET', 'name', true);

        // readyState === 3, używany np. w przypadku wyświetlania loadera w oczekiwaniu na dane:
        - xhr.onprogress; 

        // Uzyskanie odpowiedzi z serwera, nowsze użycie:
        - xhr.onload = function() {
            if(this.status === 200){
              const text = JSON.parse(this.responseText);
            }
          };

        // Starsze użycie:
        - xhr.onreadystatechange = function() {
            if(this.status === 200 && this.readyState === 4){
              const text = JSON.parse(this.responseText);
            }
          };
        
        // Błędy:
        - xhr.onerror;
        
        // Wysyłanie: 
        - xhr.send();

        ################################

        <span>Promises:</span>
        Trzy stany Promise:
        1. Pending - oczekujący
        2. Resolved - rozwiązany
        3. Reject - odrzucony

        const promise = new Promise(function(resolve, reject){
            if(!error){
              resolve();
            } else {
              reject('Error: coś poszło nie tak');
            }
        });

        .then() // zwraca odpowiedź z Promise
        .catch() // obsługa błędu
        .finally() // wykona się zawsze na końcu
        .all() // zwraca obiekt Promise z tablicą wartości zwróconych ze wszystkich spełnionych obietnic
        
        ################################

        <span>Fetch:</span> - fetch zwraca Promise
        Fetch API: json() - z body wyodrębnia json

        fetch("url")
            .then(response => response.json())
            .then(data => /* wyświetl dane w DOM */)
            .catch(error => /* wyświetl błąd */)

        ################################

        <span>Async / Await:</span>
        - po dodaniu słówka "async" funkcja zwróci nam Promise,
        - po dodaniu słówka "await" funkcja czeka aż wykona się Promise.

        async function myFunction() {
          const promise = new Promise(function(resolve, reject){
            setTimeout(()=> resolve('Hello'), 1000);
          });

          const res = await promise;
          return res;
        }

        myFunction()
          .then(res => console.log(res));        

      </pre>
  </section>

  <section>
    <h3 id="modules">Modules</h3>
    <pre>
      <span>export zmienna = przypisana_wartość</span>
      <span>import { zmienne } from './path'</span>
      - importowane nazwy zmiennych muszą być takie same jak w pliku z eksportu
      - można eksportować wiele zmiennych jednocześnie
      - w import koniecznie trzeba użyć nawiasów {}
      - w import w ścieżce należy podać rozszerzenie pliku '.js'

        // script.js
        export const first = [1, 2];
        export const second = (a, b) => a + b;

        // main.js
        import { first, second } from './script.js'

      <span>export default</span> - eksport domyślny np. funckji anonimowej
      <span>import dowolna_nazwa from './path'</span> - dodajemy dowolną nazwę bez {}
      - tylko jeden element może być eksportowany domyślnie z modułu
      - można eksportować jeden element domyślnie a reszte poprzez normalny export
      - nazwa w import z exportu domyślnego może być jaką chcemy
      - w import nie musimy używać {} przy eksporcie domyślnym

        // script.js
        export default (add) => { a + b };

        // main.js
        import naszaNazwa from './script.js'

      Import eksportu domyślnego i eksportu zwykłego jednocześnie:
      <span>import naszaNazwa, { first, second } from './path'</span>

      Import wszystkich eksportowanych elementów jako obiekt:
      <span>import * as nazwa from './path'</span>

      Zmiana nazwy podczas importu:
      <span>import { nazwa_oryginalna as nowa_nazwa } from './path'</span>

      W przeglądarce musimy dodać type="module" do script:
      <span>&ltscript src="main.js" type="module">&lt/script> </span>
    </pre>
  </section>

  <section>
    <h3 id="other">Others:</h3>
    <pre>
      <span>typeof variableName</span> - wskazuje na typ danych
      <span>console.table({a:1, b:2})</span> - wyświetla obiekt w tabeli
      <span>console.error('This is error')</span> - wyświetla error w consoli
      <span>console.warn('This is warn')</span> - wyświetla ostrzeżenie w consoli
      <span>console.time('Start')</span> - początek zliczania czasu
      <span>console.timeEnd('Stop')</span> - koniec zliczania czasu
    </pre>
  </section>

  <section>
    <h3>Słowniczek:</h3>
    <ul>
      <li>
        <span>Hoisting</span> - przeniesienie części deklaracji na początek
        zakresu. Zmienne const i let nie podlegają hoistingowi.
      </li>
      <li>
        <span>Closure (domnkięcie)</span> - mechanizm, który pomaga nam
        uzyskać dostęp do danej wartości poza funkcją i gdy ta funkcja nie
        jest już aktywna. W funkcji zwracamy inną funkcję która ma referencję
        do zmiennych funkcji pierwotnej.
      </li>
      <li>
        <span>Encapsulation (Hermetyzacja)</span> - grupowanie (zamykanie)
        metod i właściwości w obiekcie. Popularnym rozwiązaniem jest używanie
        metod pobierających (getter) i dostępowych (setter) do danych w
        obiekcie. Implementacja staje się ukryta a dostęp do danych w jednym
        obiekcie jest udostępniany innemu obiektowi za pomoca interfejsu.
      </li>
      <li>
        <span>Polimorfizm</span> - obiekt zachowuję się inaczej w zależności
        od dostarczanych danych. Polimorficzny w podstawowym znaczeniu to
        różne postacie tej samej rzeczy, zmiana kształtu.
      </li>
      <li>
        <span>Prototyp</span> - to obiekt w funkcji konstruktora,
        współdzielony przez wszystkie egzemplarze. Każdy egzemplarz ma dostęp
        do obiektu prototypu.
      </li>
      <li><span>AJAX</span> - 'Asynchronous JavaScript and XML'</li>
    </ul>
  </section>

  <!-- <script src="example.js"></script> -->
</body>

</html>